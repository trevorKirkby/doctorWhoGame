#!/usr/bin/env python

import pygame, time, math, random, sys

text1 = "Right, here are the rules. Use the arrow keys to control your movement. As the name implies, you control the doctor. You also have three other controls. F will make you move faster, but only for so long and then you must wait before sprinting again. S will use the sonic screwdriver, which interacts in various ways with the environment, closing gates and detonating things. H will heal you should you become injured, however, this uses up energy that you could also use to regenorate at the tardis if you are very badly injured. There are daleks, which will shoot you, special weapons versions, which have explosive projectiles that could be used to your advantage, and versions that are much faster and more deadly that have projectiles that only harm you, however a single shot from one such projectile will end the game. There are also silence, which will influence enemies to move towards you, cybermen, which are fast and destructive, and weeping angels, which will kill anything it can see if noone sees it. Coming soon are members of the order of the silence and the master. Good luck."

text = text1.split()

fish = raw_input("would you like instructions? y/N: ")

if fish == "y":
	for word in text:
		randthing = random.choice(range(3)) + 1
		randVariable = randthing/2
		sys.stdout.write (word)
		print " ",
		sys.stdout.flush()
		time.sleep(randVariable)
else:
	print "okay..."
	time.sleep(.3)

level = raw_input("enter tardis target phrase (blank coordinates will take you to setup1, a good place to start): ")

print "starting up game..."

everything = pygame.sprite.RenderUpdates()
everything2 = pygame.sprite.RenderUpdates()
everything7 = pygame.sprite.RenderUpdates()
foes = pygame.sprite.RenderUpdates()
deathbolts = pygame.sprite.RenderUpdates()
boombolts = pygame.sprite.RenderUpdates()
speedbolts = pygame.sprite.RenderUpdates()
sonics = pygame.sprite.RenderUpdates()
booms = pygame.sprite.RenderUpdates()
damagers = pygame.sprite.RenderUpdates()
projectiles = pygame.sprite.RenderUpdates()
health = 15
regen = 30
stamina = 350
dead = 0
saved = 0
rtn = [0,0]
rtn2 = [0,0]

class Moveable(pygame.sprite.Sprite):
	def __init__(self,pos,imageFileName):
		pygame.sprite.Sprite.__init__(self)
		self.init2(pos,imageFileName)
	def init2(self,pos,imageFileName):
		self.right = pygame.image.load(imageFileName).convert_alpha()
		self.left = pygame.transform.flip(self.right,True,False)
		self.vertical = pygame.transform.rotate(self.right,90)
		self.image = self.right
		self.direction = "right"
		self.rect = self.image.get_rect()
		self.rect.center = pos
	def move(self,dx,dy):
		screen.fill((150,150,200),self.rect)
		if dx > 0:
			self.image = self.right
			self.direction = "right"
		elif dx < 0:
			self.image = self.left
			self.direction = "left"
		collisions = pygame.sprite.spritecollide(self, everything, False)
		for other in collisions:
			if other != self:
				(awayDx,awayDy) = self.moveRelative(other,-1)
				dx = dx + 9*(awayDx)
				dy = dy + 9*(awayDy)
		self.rect.move_ip(dx,dy)
	def moveRelative(self,other,speed):
		dx = other.rect.x - self.rect.x
		dy = other.rect.y - self.rect.y
		if abs(dx) > abs(dy):
			# other is farther away in x than in y
			if dx > 0:
				return (+speed,0)
			else:
				return (-speed,0)
		else:
			if dy > 0:
				return (0,+speed)
			else:
				return (0,-speed)
	def movePerpendicular(self,other,speed):
		dx = other.rect.x - self.rect.x
		dy = other.rect.y - self.rect.y
		if abs(dx) > abs(dy):
			# this is to dodge a projectile
			if dy > 0:
				if dx > 0:
					return (+speed/2,+speed)
				else:
					return (-speed/2,+speed)
			else:
				if dx > 0:
					return (+speed/2,-speed)
				else:
					return (-speed/2,-speed)
		else:
			if dx > 0:
				if dy > 0:
					return (+speed,+speed/2)
				else:
					return (+speed,-speed/2)
			else:
				if dy > 0:
					return (-speed,+speed/2)
				else:
					return (-speed,-speed/2)
	def rangeTo(self,other):
		dx = other.rect.x - self.rect.x
		dy = other.rect.y - self.rect.y
		return math.sqrt(dx*dx + dy*dy)

class Unit(Moveable):
	def __init__(self,pos,image,health):
		Moveable.__init__(self,pos,image)
		self.projectile = None
		self.health = health
	def maintain(self):
		if self.projectile:
			if self.projectile.update() == False:
				projectiles.remove(self.projectile)
				self.projectile = None
		collisions = pygame.sprite.spritecollide(self, damagers, False)
		for other in collisions:
			if other != self:
				try:
					self.health -= other.damage
				except AttributeError:
					print "Error: Unit Damage Collisions:", other, "In damagers group with no attribute self.damage"
		if self.health <= 0:
			self.end()
	def project(self,bolt,speed=6,direction=None,target=None,accuracy=None):
		direction = self.moveRelative(doctor,speed)
		self.projectile = bolt(self.rect.center,direction)
		projectiles.add(self.projectile)
	def end(self):
		everything.remove(self)
		self.projectile.end()
		self.team.remove(self)

class Projectile(Moveable):
	#eventually enable diagonal projectile imaging
	def __init__(self,pos,direction,image,destructcount,parent=None):
		Moveable.__init__(self,pos,image)
		self.destructCountDown = destructcount
		self.direction = direction
		self.x = pos
		self.parent = parent
		self.explodable = False
		self.delay = 0
		if abs(self.direction[1]) > abs(self.direction[0]):
			self.image = self.vertical
			self.rect = self.image.get_rect()
			self.rect.center = pos
	def update(self):
		if self.delay > 0:
			self.delay -= 1
		else:
			screen.fill((150,150,200),self.rect)
			self.destructCountDown = self.destructCountDown - 1
			if self.destructCountDown == 0:
				return False
			else:
				if self.explodedable == True:
					if self.exploded == False:
						self.rect.move_ip(*self.direction)
				else:
					self.rect.move_ip(*self.direction)
				return True

class Explodable():
	def __init__(self,image,count,damage,triggers=[sonics,damagers]):
		self.explodable = True
		self.exploded = False
		self.explosion = image
		self.countdown = count
		self.x = self.rect.center
		self.shots = 0
		self.damage = damage
		self.triggers = triggers
		self.impermeable = True
	def destruct(self):
		screen.fill((150,150,200),self.rect)
                self.image = self.explosion
                self.rect = self.image.get_rect()
                self.rect.center = self.x
                everything.remove(self)
                damagers.add(self)
		self.exploded = True
	def update(self):
		if self.exploded == False:
			for group in triggers:
                        	collisions = pygame.sprite.spritecollide(self, group, False)
                        	for other in collisions:
                                	if other != self:
                                	        self.destruct()
		else:
			if self.countdown > 0:
				self.countdown = self.countdown - 1
			if self.countdown == 0:
				damagers.remove(self)
				screen.fill((150,150,200),self.rect)
				self.end()
		return self.exploded

#MIX-INS
#MIX-INS
#MIX-INS
#MIX-INS
#MIX-INS

class Detonatable(pygame.sprite.Sprite):
	def __init__(self,pos):
		pygame.sprite.Sprite.__init__(self):
		self.rect = self.image.get_rect()
		self.rect.center = pos

class doctorteam():
	def __init__():
		pass
	def update():
		pass
	def response_daleks():
		pass

class Reactor(pygame.sprite.Sprite):
	def __init__(self,pos):
		pygame.sprite.Sprite.__init__(self)
		self.image1 = pygame.image.load("reactor.png").convert_alpha()
		self.boom = pygame.image.load("explosion.png").convert_alpha()
		self.image = self.image1
		self.rect = self.image.get_rect()
		self.x = pos
		self.rect.center = pos
		self.dalekShots = 0
		self.exploded = False
		self.countdown = 6
		self.impermeable = True
	def destruct(self):
		screen.fill((150,150,200),self.rect)
                self.image = self.boom
                self.rect = self.image.get_rect()
                self.rect.center = self.x
                everything.remove(self)
                booms.add(self)
		self.exploded = True
	def PossibleExplode(self):
		if self.exploded == False:
                        collisions = pygame.sprite.spritecollide(self, sonics, False)
                        for other in collisions:
                                if other != self:
                                        self.destruct()
                        collisions = pygame.sprite.spritecollide(self, deathbolts, False)
                        for other in collisions:
                                if other != self:
                                        self.dalekShots = self.dalekShots + 1
                        if self.dalekShots == 3:
                                self.destruct()
			collisions = pygame.sprite.spritecollide(self,boombolts,False)
			for other in collisions:
				if other != self:
					self.destruct()
			collisions = pygame.sprite.spritecollide(self,booms,False)
			for other in collisions:
				if other != self:
					self.destruct()
		else:
			if self.countdown > 0:
				self.countdown = self.countdown - 1
			if self.countdown == 0:
				booms.remove(self)
				screen.fill((150,150,200),self.rect)
				reactors.remove(self)
		return self.exploded

class Bomb(pygame.sprite.Sprite):
        def __init__(self,pos):
                pygame.sprite.Sprite.__init__(self)
                self.image1 = pygame.image.load("weaponsCacheBomb.png").convert_alpha()
                self.boom = pygame.image.load("explosion.png").convert_alpha()
                self.image = self.image1
                self.rect = self.image.get_rect()
                self.x = pos
                self.rect.center = pos
                self.dalekShots = 0
                self.exploded = False
                self.countdown = 3
        def destruct(self):
                screen.fill((150,150,200),self.rect)
                self.image = self.boom
                self.rect = self.image.get_rect()
                self.rect.center = self.x
                everything.remove(self)
                booms.add(self)
                self.exploded = True
        def PossibleExplode(self):
                if self.exploded == False:
                        collisions = pygame.sprite.spritecollide(self, sonics, False)
                        for other in collisions:
                                if other != self:
                                        self.destruct()
                        collisions = pygame.sprite.spritecollide(self, deathbolts, False)
                        for other in collisions:
                                if other != self:
                                        self.dalekShots = self.dalekShots + 1
			collisions = pygame.sprite.spritecollide(self,boombolts,False)
			for other in collisions:
				if other != self:
					self.destruct()
			collisions = pygame.sprite.spritecollide(self,booms,False)
			for other in collisions:
				if other != self:
					self.destruct()
                        if self.dalekShots == 3:
                                self.destruct()
                else:
                        if self.countdown > 0:
                                self.countdown = self.countdown - 1
                        else:
                                booms.remove(self)
                                screen.fill((150,150,200),self.rect)
                                bombs.remove(self)
                return self.exploded

class TimeRift(pygame.sprite.Sprite):
        def __init__(self,pos,count,life):
                pygame.sprite.Sprite.__init__(self)
                self.image = pygame.image.load("TimeRift.png").convert_alpha()
                self.rect = self.image.get_rect()
                self.x = pos
                self.rect.center = pos
                self.countdown = life
		self.count = count
		booms.add(self)
        def update(self,others):
		for unit in others:
			if self.rangeTo(unit) < 120:
				unit.move(*moveRelativeTo(self,4))
		collisions = pygame.sprite.spritecollide(self, projectiles, False)
                for other in collisions:
	                if other != self:
                         	x,y = projectile.direction
				projectile.direction = (x*-1,y*-1)
				projectile.delay = count
                if self.countdown > 0:
	                self.countdown = self.countdown - 1
                else:
                     	booms.remove(self)
                        screen.fill((150,150,200),self.rect)
                        rifts.remove(self)

class Crate(pygame.sprite.Sprite):
        def __init__(self,pos):
                pygame.sprite.Sprite.__init__(self)
                self.image1 = pygame.image.load("crate.png").convert_alpha()
                self.boom = pygame.image.load("crateFalling.png").convert_alpha()
                self.image = self.image1
                self.rect = self.image.get_rect()
                self.x = pos
                self.rect.center = pos
                self.dalekShots = 0
                self.exploded = False
                self.countdown = 3
        def destruct(self):
                screen.fill((150,150,200),self.rect)
                self.image = self.boom
                self.rect = self.image.get_rect()
                self.rect.center = self.x
                booms.add(self)
                self.exploded = True
        def PossibleExplode(self):
                if self.exploded == False:
                        collisions = pygame.sprite.spritecollide(self, sonics, False)
                        for other in collisions:
                                if other != self:
                                        self.destruct()
			collisions = pygame.sprite.spritecollide(self, boombolts, False)
                        for other in collisions:
                                if other != self:
                                        self.destruct()
			collisions = pygame.sprite.spritecollide(self,booms,False)
			for other in collisions:
				if other != self:
					self.destruct()
                else:
                        if self.countdown > 0:
                                self.countdown = self.countdown - 1
                        if self.countdown == 0:
                                booms.remove(self)
                                screen.fill((150,150,200),self.rect)
                                crates.remove(self)
                return self.exploded

class BoomBolt(Moveable):
	def __init__(self,pos,direction,parent=None):
		Moveable.__init__(self,pos,"deathRay.png")
		self.destructCountDown = 45
		self.direction = direction
		self.x = pos
		self.boom = "explosion.png"
		if abs(self.direction[1]) > abs(self.direction[0]):
			self.image = self.vertical
			self.rect = self.image.get_rect()
			self.rect.center = pos
		self.exploded = False
                self.countdown = 3
		self.parent = parent
        def destruct(self):
                screen.fill((150,150,200),self.rect)
                self.init2(self.rect.center,self.boom)
                booms.add(self)
                self.exploded = True
        def PossibleExplode(self):
                if self.exploded == False:
			collisions = pygame.sprite.spritecollide(self, everything2, False)
                        for other in collisions:
                                if other != self and "doctor" != self.parent:
                                        self.destruct()
                if self.exploded == True:
                        if self.countdown > 0:
                                self.countdown = self.countdown - 1
                        if self.countdown == 0:
                                booms.remove(self)
                                screen.fill((150,150,200),self.rect)
                                boombolts.remove(self)
		return self.exploded
	def update(self):
		screen.fill((150,150,200),self.rect)
		self.destructCountDown = self.destructCountDown - 1
		if self.destructCountDown == 0:
			return False
		else:
			if self.exploded == False:
				self.rect.move_ip(*self.direction)
				self.rect.move_ip(*self.direction)
			collisions = pygame.sprite.spritecollide(self, barriers, False)
			for other in collisions:
				if other != self and other.impermeable == True:
					self.destructCountDown = 1
			return True

class SpecialWeaponsDalek(Moveable):
	def __init__(self,pos):
		Moveable.__init__(self,pos,"specialWeaponsDalek.png")
		self.boombolt = None
		self.life = 300
		self.insane = False
		self.spinny = False
		self.spin = [1,0]
		self.spincount = 0
		self.spincount2 = 0
	def update(self):
		if self.spinny != True:
			if self.insane != True:
				if self.rangeTo(doctor) < 415:
					self.move(*self.moveRelative(doctor,1))
			else:
				for dalek in daleks:
					if self.rangeTo(dalek) < 415:
						self.move(*self.moveRelative(dalek,1))
						break
		else:
			self.spincount2 += 1
			if self.spincount2 == 25:
				self.spincount2 = 0
				self.spincount += 1
			if self.spincount == 4:
				self.spincount = 0
			self.move(*(self.spin[0],self.spin[1]))
			if self.spincount == 0:
				self.spin = [1,0]
			if self.spincount == 1:
				self.spin = [0,1]
			if self.spincount == 2:
				self.spin = [-1,0]
			if self.spincount == 3:
				self.spin = [0,-1]
		if self.boombolt:
			if self.boombolt.update() == False:
				boombolts.remove(self.boombolt)
				self.boombolt = None
		else:
			if self.insane != True:
				if self.rangeTo(doctor) < 200:
					direction = self.moveRelative(doctor,6)
					self.boombolt = BoomBolt(self.rect.center,direction)
					boombolts.add(self.boombolt)
			else:
				for dalek in daleks:
					if self.rangeTo(dalek) < 200:
						direction = self.moveRelative(dalek,6)
						self.boombolt = BoomBolt(self.rect.center,direction)
						boombolts.add(self.boombolt)
						break
		collisions = pygame.sprite.spritecollide(self, booms, False)
		if len(collisions) > 0:
			everything.remove(self)
			everything7.remove(self)
			boombolts.remove(self.boombolt)
			booms.remove(self.boombolt)
			weapondaleks.remove(self)

class VentGate(pygame.sprite.Sprite):
	def __init__(self,pos):
		pygame.sprite.Sprite.__init__(self)
		self.image1 = pygame.image.load("openGate.png").convert_alpha()
		self.image2 = pygame.image.load("closedGate.png").convert_alpha()
		self.image = self.image1
		self.closed = False
		self.rect = self.image.get_rect()
		self.rect.center = pos
	def openedClosed(self):
		collisions = pygame.sprite.spritecollide(self, sonics, False)
		for other in collisions:
			if other != self:
				if self.image == self.image1:
					self.image = self.image2
					everything.add(self)
				else:
					self.image = self.image1
					everything.remove(self)
					screen.fill((150,150,200),self.rect)

class Beamer(pygame.sprite.Sprite):
	def __init__(self,pos,coordinates):
		pygame.sprite.Sprite.__init__(self)
		self.image = pygame.image.load("beamer.png").convert_alpha()
		self.rect = self.image.get_rect()
		self.rect.center = pos
		self.coordinates = coordinates
	def update(self):
		collisions = pygame.sprite.spritecollide(self, sonics, False)
		for other in collisions:
			if other != self:
				collisions1 = pygame.sprite.spritecollide(self, everything, False)
				for other2 in collisions1:
					if other2 != self:
						other2.move(*self.coordinates)

class Wall(pygame.sprite.Sprite):
	def __init__(self,pos,impermeable=False):
		pygame.sprite.Sprite.__init__(self)
		self.image = pygame.image.load("barrier.png").convert()
		self.rect = self.image.get_rect()
		self.rect.center = pos
		self.impermeable = impermeable
	def update(self):
		collisions = pygame.sprite.spritecollide(self, booms, False)
		for other in collisions:
			if other != self:
				everything.remove(self)
				barriers.remove(self)

class StoneWall(pygame.sprite.Sprite):
	def __init__(self,pos,impermeable=False):
		pygame.sprite.Sprite.__init__(self)
		self.image = pygame.image.load("stonewall.png").convert()
		self.rect = self.image.get_rect()
		self.rect.center = pos
		self.impermeable = impermeable
	def update(self):
		collisions = pygame.sprite.spritecollide(self, booms, False)
		for other in collisions:
			if other != self:
				everything.remove(self)
				barriers.remove(self)

class Tardis(pygame.sprite.Sprite):
        def __init__(self,pos):
                pygame.sprite.Sprite.__init__(self)
                self.image = pygame.image.load("tardis.png").convert_alpha()
                self.rect = self.image.get_rect()
                self.rect.center = pos

class DeathBolt(Moveable):
	def __init__(self,pos,direction):
		Moveable.__init__(self,pos,"deathRay.png")
		self.destructCountDown = 39
		self.direction = direction
		if abs(self.direction[1]) > abs(self.direction[0]):
			self.image = self.vertical
			self.rect = self.image.get_rect()
			self.rect.center = pos
	def update(self):
		screen.fill((150,150,200),self.rect)
		self.destructCountDown = self.destructCountDown - 1
		if self.destructCountDown == 0:
			return False
		else:
			self.rect.move_ip(*self.direction)
			self.rect.move_ip(*self.direction)
			collisions = pygame.sprite.spritecollide(self, everything, False)
			for other in collisions:
				if other == doctor:
					print "you just got shot, health at", health, "out of 15"
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
			collisions = pygame.sprite.spritecollide(self, barriers, False)
			for other in collisions:
				if other != self and other.impermeable == True:
					self.destructCountDown = 1
			return True

class Dalek(Moveable):
	def __init__(self,pos):
		Moveable.__init__(self,pos,"dalek.png")
		self.deathbolt = None
		self.paralyzed = False
		self.terror = False
	def update(self):
		if self.paralyzed != True:
			if self.terror != True:
				if self.rangeTo(doctor) < 415:
					self.move(*self.moveRelative(doctor,1))
				elif self.rangeTo(pond) < 300:
					self.move(*self.moveRelative(pond,1))
				for civilian in civilians:
					if self.rangeTo(civilian) < 250:
						self.move(*self.moveRelative(civilian,1))
			else:
				if self.rangeTo(doctor) < 415:
					self.move(*self.moveRelative(doctor,-1))
				elif self.rangeTo(pond) < 300:
					self.move(*self.moveRelative(pond,-1))
				for civilian in civilians:
					if self.rangeTo(civilian) < 250:
						self.move(*self.moveRelative(civilian,-1))
		if self.terror != True:
			if self.deathbolt:
				if self.deathbolt.update() == False:
					deathbolts.remove(self.deathbolt)
					self.deathbolt = None
			elif self.rangeTo(doctor) < 200:
				direction = self.moveRelative(doctor,6)
				self.deathbolt = DeathBolt(self.rect.center,direction)
				deathbolts.add(self.deathbolt)
			for civilian in civilians:
				if self.deathbolt == None and self.rangeTo(civilian) < 150:
					direction = self.moveRelative(civilian,6)
					self.deathbolt = DeathBolt(self.rect.center,direction)
					deathbolts.add(self.deathbolt)
			if self.deathbolt == None and self.rangeTo(pond) < 175:
				direction = self.moveRelative(pond,6)
				self.deathbolt = DeathBolt(self.rect.center,direction)
				deathbolts.add(self.deathbolt)
		else:
			if self.deathbolt:
				if self.deathbolt.update() == False:
					deathbolts.remove(self.deathbolt)
					self.deathbolt = None
		collisions = pygame.sprite.spritecollide(self, booms, False)
		for other in collisions:
			if other != self:
				everything.remove(self)
				everything7.remove(self)
				deathbolts.remove(self.deathbolt)
				daleks.remove(self)

class SpeedyDalek(Moveable):
	def __init__(self,pos):
		Moveable.__init__(self,pos,"specialWeaponsDalek.png")
		self.speedbolt = None
		self.side = False
		self.paralyzed = False
		self.mark = False
	def update(self):
		if self.paralyzed == True:
			pass
		elif self.side != True:
				if self.rangeTo(doctor) < 415:
					self.move(*self.moveRelative(doctor,2))
		else:
			self.move(*(-2,0))
		if self.speedbolt:
			if self.speedbolt.update() == False:
				speedbolts.remove(self.speedbolt)
				self.speedbolt = None
		elif self.rangeTo(doctor) < 200:
			direction = self.moveRelative(doctor,6)
			self.speedbolt = SpeedBolt(self.rect.center,direction)
			speedbolts.add(self.speedbolt)
		for boombolt in boombolts:
			if self.rangeTo(boombolt) < 250:
				self.move(*self.movePerpendicular(boombolt,-3))
		collisions = pygame.sprite.spritecollide(self, booms, False)
		for other in collisions:
			if other != self:
				everything.remove(self)
				everything7.remove(self)
				speedbolts.remove(self.speedbolt)
				speedydaleks.remove(self)
		if self.mark == False:
			if self.paralyzed == True:
				self.image = pygame.image.load("petrified.png").convert_alpha()
				self.right = pygame.image.load("petrified.png").convert_alpha()
				self.left = pygame.transform.flip(self.right,True,False)
				self.mark = True

class SpeedBolt(Moveable):
	def __init__(self,pos,direction):
		Moveable.__init__(self,pos,"deathRay.png")
		self.destructCountDown = 8
		self.direction = direction
		self.shots = 0
		if abs(self.direction[1]) > abs(self.direction[0]):
			self.image = self.vertical
			self.rect = self.image.get_rect()
			self.rect.center = pos
	def update(self):
		screen.fill((150,150,200),self.rect)
		self.destructCountDown = self.destructCountDown - 1
		if self.destructCountDown == 0:
			return False
		else:
			self.rect.move_ip(*self.direction)
			self.rect.move_ip(*self.direction)
			self.rect.move_ip(*self.direction)
			self.rect.move_ip(*self.direction)
			self.rect.move_ip(*self.direction)
			self.rect.move_ip(*self.direction)
			collisions = pygame.sprite.spritecollide(self, everything, False)
			for other in collisions:
				if other == doctor:
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					print "Game Over --you died    Note: avoid the faster daleks repeating weapons, as they will kill you and only you instantly."
					raise SystemExit
			collisions = pygame.sprite.spritecollide(self, barriers, False)
			for other in collisions:
				if other != self and other.impermeable == True:
					self.destructCountDown = 1
			return True



class Civilian(Moveable):
	def __init__(self,pos):
		Moveable.__init__(self,pos,"civilian.png")
		self.gone = False
	def update(self,saved1,dead1):
		if self.gone == None:
			self.gone = True
		elif self.gone == True:
			everything.remove(self)
			everything7.remove(self)
			civilians.remove(self)
		for dalek in daleks:
			if self.rangeTo(dalek) < 350:
				self.move(*self.moveRelative(dalek,-2))
		for dalek in speedydaleks:
			if self.rangeTo(dalek) < 350:
				self.move(*self.moveRelative(dalek,-2))
		for barrier in barriers:
			if self.rangeTo(barrier) < 5:
				self.move(*self.moveRelative(barrier,-2))
		if self.rangeTo(doctor) < 350:
			if self.rangeTo(doctor) < 90:
				self.move(*self.moveRelative(doctor,-2))
			else:
				self.move(*self.moveRelative(doctor,2))
		elif self.rangeTo(pond) < 350:
			if self.rangeTo(pond) < 90:
				self.move(*self.moveRelative(pond,-2))
			else:
				self.move(*self.moveRelative(pond,2))
		for tardis in tardises:
			if self.rangeTo(tardis) < 150:
				self.move(*self.moveRelative(tardis,2))
			if self.rangeTo(tardis) < 50:
				self.gone = True
				saved1 = saved1 + 1
				print saved1, "saved"
				return [saved1,dead1]
		collisions = pygame.sprite.spritecollide(self, booms, False)
		for other in collisions:
			if other != self:
				self.gone = True
				dead1 = dead1 + 1
				print dead1, "dead"
				return [saved1,dead1]
		collisions = pygame.sprite.spritecollide(self, deathbolts, False)
		for other in collisions:
			if other != self:
				self.gone = True
				dead1 = dead1 + 1
				print dead1, "dead"
				return  [saved1,dead1]
		return [saved,dead]

class WeepingAngel(Moveable):
	def __init__(self,pos):
		Moveable.__init__(self,pos,"weepingAngel.png")
		self.timeLapse = 20
		self.counter = 0
	def update(self,sights):
		canattack = True
		for part in sights:
			direction = "right"
			if part.rect.x > self.rect.x:
				direction = "left"
			if part == self or part.__class__.__name__== 'WeepingAngel':
				pass
			elif part.direction == direction and self.rangeTo(part) < 230:
				canattack = False
			else:
				pass
		if canattack == True:
			for part in sights:
				if part == self or part.__class__.__name__== 'WeepingAngel':
					pass
				elif self.rangeTo(part) < 230:
					self.attacking(part)
					break
		if self.counter > 0:
			self.counter -= 1
			if self.counter == 0:
				booms.remove(self)
	def attacking(self,target):
		if self.timeLapse < 0:
			booms.add(self)
			self.move(*self.moveRelative(target,15))
			self.move(*self.moveRelative(target,15))
			self.move(*self.moveRelative(target,15))
			self.move(*self.moveRelative(target,15))
			self.move(*self.moveRelative(target,15))
			self.move(*self.moveRelative(target,15))
			self.timeLapse = 20
			self.counter = 5 
		else:
			self.timeLapse = self.timeLapse -1

class Silence(Moveable):
	def __init__(self,pos):
		Moveable.__init__(self,pos,"silence .png")
		self.blind = False
		self.dir = [(1,0),1]
	def update(self,sights):
		if self.blind:
			if self.dir[1] < 1:
				self.dir = [random.choice([(1,0),(0,1),(-1,0),(0,-1)]),random.choice(range(25))]
			else:
				self.move(*self.dir[0])
				self.dir[1] -= 1
		elif random.choice([True,False]):
			self.move(*self.moveRelative(doctor,1))
		for part in sights:
			if part == self or part == doctor:
				continue
			if self.rangeTo(part) < 100:
				part.move(*part.moveRelative(doctor,2))
				part.move(*part.moveRelative(self,-2))
		collisions = pygame.sprite.spritecollide(self, booms, False)
		if len(collisions) > 0:
			everything.remove(self)
			silence.remove(self)
		collisions = pygame.sprite.spritecollide(self, deathbolts, False)
		if len(collisions) > 0:
			everything.remove(self)
			silence.remove(self)


class cyberbolt(Moveable):
	def __init__(self,pos,direction):
		Moveable.__init__(self,pos,"cyberbolt.png")
		self.destructCountDown = 10
		self.direction = direction
		self.x = pos
		self.boom = "explosion.png"
		if abs(self.direction[1]) > abs(self.direction[0]):
			self.image = self.vertical
			self.rect = self.image.get_rect()
			self.rect.center = pos
		self.exploded = False
                self.countdown = 3
        def destruct(self):
                screen.fill((150,150,200),self.rect)
                self.init2(self.rect.center,self.boom)
                booms.add(self)
                self.exploded = True
        def PossibleExplode(self):
                if self.exploded == False:
			collisions = pygame.sprite.spritecollide(self, everything2, False)
                        for other in collisions:
                                if other != self:
                                        self.destruct()
                if self.exploded == True:
                        if self.countdown > 0:
                                self.countdown = self.countdown - 1
                        if self.countdown == 0:
                                booms.remove(self)
                                screen.fill((150,150,200),self.rect)
                                boombolts.remove(self)
		return self.exploded
	def update(self):
		screen.fill((150,150,200),self.rect)
		self.destructCountDown = self.destructCountDown - 1
		if self.destructCountDown == 0:
			return False
		else:
			if self.exploded == False:
				self.rect.move_ip(*self.direction)
				self.rect.move_ip(*self.direction)
			collisions = pygame.sprite.spritecollide(self, barriers, False)
			for other in collisions:
				if other != self and other.impermeable == True:
					self.destructCountDown = 1
			return True

class cyberman(Moveable):
	def __init__(self,pos):
		Moveable.__init__(self,pos,"cyber.png")
		self.boombolt = None
		self.life = 300
		self.spazzy=False
		self.count = 0
	def update(self,others):
		target = doctor
		for other in others:
			if self.rangeTo(other) < 250:
				if other != self:
					if self.spazzy != True:
						self.move(*self.moveRelative(other,5))
					else:
						self.count += 1
						if self.count == 10:
							self.count = 0
						if self.count < 4:
							self.move(*(5,0))
						else:
							self.move(*(0,5))
					target = other
					break
		if self.boombolt:
			if self.boombolt.update() == False:
				boombolts.remove(self.boombolt)
				self.boombolt = None
		elif self.rangeTo(target) < 200:
			direction = self.moveRelative(target,15)
			self.boombolt = cyberbolt(self.rect.center,direction)
			boombolts.add(self.boombolt)
		collisions = pygame.sprite.spritecollide(self, booms, False)
		if len(collisions) > 0:
			everything.remove(self)
			everything7.remove(self)
			boombolts.remove(self.boombolt)
			booms.remove(self.boombolt)
			cybers.remove(self)

class silencebolt(Moveable):
	def __init__(self,pos,direction):
		Moveable.__init__(self,pos,"silencebolt.png")
		booms.add(self)
		self.destructCountDown = 10
		self.direction = direction
		if abs(self.direction[1]) > abs(self.direction[0]):
			self.image = self.vertical
			self.rect = self.image.get_rect()
			self.rect.center = pos
	def update(self):
		screen.fill((150,150,200),self.rect)
		self.destructCountDown = self.destructCountDown - 1
		if self.destructCountDown == 0:
			return False
		else:
			self.rect.move_ip(*self.direction)
			self.rect.move_ip(*self.direction)
			collisions = pygame.sprite.spritecollide(self, everything, False)
			for other in collisions:
				if other == doctor:
					print "you just got shot, health at", health, "out of 15"
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
					self.rect.move_ip(*self.direction)
			collisions = pygame.sprite.spritecollide(self, barriers, False)
			for other in collisions:
				if other != self and other.impermeable == True:
					self.destructCountDown = 1
			return True

class silenceorder(Moveable):
	def __init__(self,pos):
		Moveable.__init__(self,pos,"silenceorder.png")
		self.deathbolt = None
		self.dir = [(2,0),1]
	def update(self):
		if self.dir[1] < 1:
			self.dir = [random.choice([(2,0),(0,2),(-2,0),(0,-2)]),random.choice(range(25))]
		else:
			self.move(*self.dir[0])
			self.dir[1] -= 1
		if self.deathbolt:
			if self.deathbolt.update() == False:
				deathbolts.remove(self.deathbolt)
				self.deathbolt = None
		elif self.rangeTo(doctor) < 400:
			if self.rect.x == doctor.rect.x or self.rect.y == doctor.rect.y or self.rect.x == doctor.rect.x+1 or self.rect.y == doctor.rect.y+1 or self.rect.x == doctor.rect.x-1 or self.rect.y == doctor.rect.y-1:
				direction = self.moveRelative(doctor,14)
				self.deathbolt = silencebolt(self.rect.center,direction)
				deathbolts.add(self.deathbolt)
		for cyber in cybers:
			if self.rangeTo(cyber) < 400 and self.deathbolt == None:
				if self.rect.x == cyber.rect.x or self.rect.y == cyber.rect.y or self.rect.x == cyber.rect.x+1 or self.rect.y == cyber.rect.y+1 or self.rect.x == cyber.rect.x-1 or self.rect.y == cyber.rect.y-1:
					direction = self.moveRelative(cyber,14)
					self.deathbolt = silencebolt(self.rect.center,direction)
					deathbolts.add(self.deathbolt)
		collisions = pygame.sprite.spritecollide(self, booms, False)
		for other in collisions:
			if other != self and other != self.deathbolt:
				everything.remove(self)
				everything7.remove(self)
				deathbolts.remove(self.deathbolt)
				daleks.remove(self)


class Pond(Moveable):
	def __init__(self,pos):
		Moveable.__init__(self,pos,"amelia pond.png")
		self.sonicWave = None
	def update(self):
		if self.rangeTo(doctor) < 200:
			if self.rangeTo(doctor) < 100:
				self.move(*self.moveRelative(doctor,-1))
			elif self.rangeTo(doctor) < 200:
				pass
			else:
				self.move(*self.moveRelative(doctor,2))
		else:
			for dalek in daleks:
				if self.rangeTo(dalek) < 375:
					self.move(*self.moveRelative(dalek,-2))
			for speedydalek in speedydaleks:
				if self.rangeTo(speedydalek) < 375:
					self.move(*self.moveRelative(speedydalek,-2))
			for weapondalek in weapondaleks:
				if self.rangeTo(weapondalek) < 375:
					self.move(*self.moveRelative(weapondalek,-2))
			for angel in angels:
				if self.rangeTo(angel) < 375:
					self.move(*self.moveRelative(angel,-2))
		if self.sonicWave:
			if self.sonicWave.update() == False:
				sonics.remove(self.sonicWave)
				self.sonicWave = None
		for bomb in bombs:
			if self.rangeTo(bomb) > 90 and self.rangeTo(bomb) < 300:
				if self.sonicWave == None:
					print "SONIC"
					direction = self.moveRelative(bomb,6)
					self.sonicWave = sonicWave(self.rect.center,direction)
					sonics.add(self.sonicWave)
		for boom in booms:
			if self.rangeTo(boom) < 30:
				self.move(*self.moveRelative(boom,-6))
		for deathbolt in deathbolts:
			if self.rangeTo(deathbolt) < 200:
				if self.rangeTo(doctor) < 375:
					self.move(*self.movePerpendicular(deathbolt,-8))
				else:
					for dalek in daleks:
						if self.rangeTo(dalek) < 375:
							self.move(*self.movePerpendicular(deathbolt,-8))
		for speedbolt in speedbolts:
			if self.rangeTo(speedbolt) < 230:
				if self.rangeTo(doctor) < 375:
					self.move(*self.movePerpendicular(speedbolt,-8))
				else:
					for dalek in daleks:
						if self.rangeTo(dalek) < 375:
							self.move(*self.movePerpendicular(speedbolt,-8))
				self.move(*self.movePerpendicular(speedbolt,-8))
		for boombolt in boombolts:
			if self.rangeTo(boombolt) < 200:
				self.move(*self.movePerpendicular(boombolt,-8))
		for barrier in barriers:
			if self.rangeTo(barrier) < 5:
				self.move(*self.moveRelative(barrier,-3))
		collisions1 = pygame.sprite.spritecollide(self, booms, False)
		for other in collisions1:
			if other != self:
				pass
				#everything.remove(self)
				#ponds.remove(self)
				#sonics.remove(self.sonicWave)
				#print "Game Over --Amelia Pond died"
				#raise SystemExit
		collisions2 = pygame.sprite.spritecollide(self, deathbolts, False)
		for other in collisions2:
			if other != self:
				pass
				#everything.remove(self)
				#ponds.remove(self)
				#sonics.remove(self.sonicWave)
				#print "Game Over --Amelia Pond died"
				#raise SystemExit

class Rory(Moveable):
	def __init__(self,pos):
		Moveable.__init__(self,pos,"rory.png")
		self.counting = 0
	def update(self):
		if self.counting > 0:
			self.counting -= 1
			if self.counting == 0:
				booms.remove(self)
		if self.rangeTo(doctor) < 375:
			if self.rangeTo(doctor) < 100:
				self.move(*self.moveRelative(doctor,-1))
			elif self.rangeTo(doctor) < 200:
				pass
			else:
				self.move(*self.moveRelative(doctor,2))
		else:
			for dalek in daleks:
				if self.rangeTo(dalek) < 400:
					self.move(*self.moveRelative(dalek,-2))
			for dalek in cybers:
				if self.rangeTo(dalek) < 375:
					self.move(*self.moveRelative(dalek,-2))
			for speedydalek in speedydaleks:
				if self.rangeTo(speedydalek) < 375:
					self.move(*self.moveRelative(speedydalek,-1))
			for weapondalek in weapondaleks:
				if self.rangeTo(weapondalek) < 375:
					self.move(*self.moveRelative(weapondalek,-1))
			for angel in angels:
				if self.rangeTo(angel) < 375:
					self.move(*self.moveRelative(angel,-1))
		for dalek in daleks:
			if self.rangeTo(dalek) < 100:
				self.move(*self.moveRelative(dalek,7))
				booms.add(self)
				self.counting = 5
		for dalek in cybers:
			if self.rangeTo(dalek) < 100:
				self.move(*self.moveRelative(dalek,7))
				booms.add(self)
				self.counting = 5
		for dalek in silence:
			if self.rangeTo(dalek) < 200:
				self.move(*self.moveRelative(dalek,7))
				booms.add(self)
				self.counting = 5
		for boom in booms:
			if self.rangeTo(boom) < 70:
				self.move(*self.moveRelative(boom,-6))
		for deathbolt in deathbolts:
			if self.rangeTo(deathbolt) < 200:
				if self.rangeTo(doctor) < 375:
					self.move(*self.movePerpendicular(deathbolt,-8))
				else:
					for dalek in daleks:
						if self.rangeTo(dalek) < 375:
							self.move(*self.movePerpendicular(deathbolt,-8))
		for speedbolt in speedbolts:
			if self.rangeTo(speedbolt) < 230:
				if self.rangeTo(doctor) < 375:
					self.move(*self.movePerpendicular(speedbolt,-2))
				else:
					for dalek in daleks:
						if self.rangeTo(dalek) < 375:
							self.move(*self.movePerpendicular(speedbolt,-2))
				self.move(*self.movePerpendicular(speedbolt,-5))
		for boombolt in boombolts:
			if self.rangeTo(boombolt) < 200:
				self.move(*self.movePerpendicular(boombolt,-8))
		for barrier in barriers:
			if self.rangeTo(barrier) < 10:
				self.move(*self.moveRelative(barrier,-1))
		collisions1 = pygame.sprite.spritecollide(self, booms, False)
		for other in collisions1:
			if other != self:
				#everything.remove(self)
				#ponds.remove(self)
				#print "Game Over --Rory died"
				#raise SystemExit
				pass
		collisions2 = pygame.sprite.spritecollide(self, deathbolts, False)
		for other in collisions2:
			if other != self:
				#everything.remove(self)
				#ponds.remove(self)
				#print "Game Over --Rory died"
				#raise SystemExit
				pass

class sonicWave(Moveable):
	def __init__(self,pos,direction):
		Moveable.__init__(self,pos,"sonicBolt.png")
		self.destructCountDown = 45
		self.direction = direction
		if abs(self.direction[1]) > abs(self.direction[0]):
			self.image = self.vertical
			self.rect = self.image.get_rect()
			self.rect.center = pos
	def update(self):
		screen.fill((150,150,200),self.rect)
		self.destructCountDown = self.destructCountDown - 1
		if self.destructCountDown == 0:
			return False
		else:
			self.rect.move_ip(*self.direction)
			self.rect.move_ip(*self.direction)
			collisions = pygame.sprite.spritecollide(self, ventGates, False)
			for other in collisions:
				if other != self:
					self.destructCountDown = 1
			collisions = pygame.sprite.spritecollide(self, reactors, False)
			for other in collisions:
				if other != self:
					self.destructCountDown = 1
			collisions = pygame.sprite.spritecollide(self, everything7, False)
			for other in collisions:
				if other != self:
					other.move(*other.moveRelative(doctor,-2))
			collisions = pygame.sprite.spritecollide(self, barriers, False)
			for other in collisions:
				if other != self and other.impermeable == True:
					self.destructCountDown = 1
			return True

class returner():
	def __init__(thing):
		pass
	def update(thing):
		return True

class regenbolt(Moveable):
	def __init__(self,pos,direction):
		Moveable.__init__(self,pos,"regenbolt.png")
		self.destructCountDown = 100
		self.direction = direction
		self.past = []
		if abs(self.direction[1]) > abs(self.direction[0]):
			self.image = self.vertical
			self.rect = self.image.get_rect()
			self.rect.center = pos
	def update(self):
		screen.fill((150,150,200),self.rect)
		self.destructCountDown = self.destructCountDown - 1
		if self.destructCountDown == 0:
			return False
		else:
			self.rect.move_ip(*self.direction)
			self.rect.move_ip(*self.direction)
			self.rect.move_ip(*self.direction)
			self.rect.move_ip(*self.direction)
			self.rect.move_ip(*self.direction)
			self.rect.move_ip(*self.direction)
			randomizer = random.choice(range(15))
			randomizer2 = random.choice(range(35))
			collisions = pygame.sprite.spritecollide(self, everything, False)
			for other in collisions:
				if other != self:
					if randomizer2 == 7:
						self.destruct()
			collisions = pygame.sprite.spritecollide(self, daleks, False)
			for other in collisions:
				if other != self:
					if other in self.past:
						pass
					else:
						self.past.append(other)
						other.move(*other.moveRelative(doctor,-20))
						if randomizer > 9:
							print "STRIKE"
							deathbolts.remove(other.deathbolt)
							other.move(*other.movePerpendicular(doctor,-60))
						elif randomizer == 8:
							print "TERROR"
							other.terror = True
						elif randomizer < 3:
							print "EMP"
							other.paralyzed = True
							deathbolts.remove(other.deathbolt)
							other.deathbolt = returner()
						elif randomizer >= 5:
							print "MOTORS DISABLED"
							other.paralyzed = True
						else:
							print "WEAPONS DISABLED"
							deathbolts.remove(other.deathbolt)
							other.deathbolt = returner()
			collisions = pygame.sprite.spritecollide(self, weapondaleks, False)
			for other in collisions:
				if other != self:
					if other in self.past:
						pass
					else:
						self.past.append(other)
						other.move(*other.moveRelative(doctor,-20))
						if randomizer > 10:
							print "STRIKE"
							boombolts.remove(other.boombolt)
							other.move(*other.movePerpendicular(doctor,-60))
						elif randomizer == 9:
							print "INSANITY"
							other.insane = True
						elif randomizer < 4:
							print "ENTOMBED"
							things = pygame.sprite.RenderUpdates()
							thing = Wall(other.rect.center,True)
							everything.add(thing)
							things.add(thing)
							barriers.add(thing)
							pygame.display.update(things.draw((screen)))
							everything.remove(other)
							everything7.remove(other)
							boombolts.remove(other.boombolt)
							booms.remove(other.boombolt)
							weapondaleks.remove(other)
							things = None
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
						elif randomizer >= 5:
							print "MOTORS SABOTAGED"
							other.spinny = True
						else:
							print "WEAPONS SABOTAGED"
							everything2.add(other)
			collisions = pygame.sprite.spritecollide(self, speedydaleks, False)
			for other in collisions:
				if other != self:
					if other in self.past:
						pass
					else:
						self.past.append(other)
						other.move(*other.moveRelative(doctor,-20))
						if randomizer > 12:
							print "STRIKE"
							speedbolts.remove(other.speedbolt)
							other.move(*other.movePerpendicular(doctor,-60))
						elif randomizer >= 9:
							print "DEGRADED"
							things = pygame.sprite.RenderUpdates()
							thing = Dalek(other.rect.center)
							everything.add(thing)
							everything2.add(thing)
							everything7.add(thing)
							things.add(thing)
							daleks.add(thing)
							pygame.display.update(things.draw((screen)))
							everything.remove(other)
							everything7.remove(other)
							speedbolts.remove(other.speedbolt)
							speedydaleks.remove(other)
							things = None
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
						elif randomizer < 5:
							print "PETRIFIED"
							other.paralyzed = True
							speedbolts.remove(other.speedbolt)
							other.speedbolt = returner()
						elif randomizer > 6:
							print "MOTORS BROKEN"
							other.side = True
						else:
							print "WEAPONS DISABLED"
							speedbolts.remove(other.speedbolt)
							other.speedbolt = returner()
			collisions = pygame.sprite.spritecollide(self, cybers, False)
			for other in collisions:
				if other != self:
					if other in self.past:
						pass
					else:
						self.past.append(other)
						other.move(*other.moveRelative(doctor,-20))
						if randomizer > 9:
							print "STRIKE"
							boombolts.remove(other.boombolt)
							other.move(*other.movePerpendicular(doctor,-60))
						elif randomizer == 8:
							print "MOTORS CORRUPTED"
							self.spazzy=True
						elif randomizer < 3:
							print "CIVILIAN RESTORED"
							things = pygame.sprite.RenderUpdates()
							thing = Civilian(other.rect.center)
							everything.add(thing)
							everything2.add(thing)
							everything7.add(thing)
							things.add(thing)
							civilians.add(thing)
							pygame.display.update(things.draw((screen)))
							everything.remove(other)
							everything7.remove(other)
							boombolts.remove(other.boombolt)
							cybers.remove(other)
							things = None
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
							self.rect.move_ip(*self.direction)
						elif randomizer >= 5:
							print "WEAPONS SABOTAGED"
							everything2.add(other)
						else:
							print "WEAPONS DISABLED"
							boombolts.remove(other.boombolt)
							other.boombolt = returner()
			collisions = pygame.sprite.spritecollide(self, angels, False)
			for other in collisions:
				if other != self:
					if other in self.past:
						pass
					else:
						self.past.append(other)
						other.move(*other.moveRelative(doctor,-20))
						if randomizer > 9:
							print "STRIKE"
							other.timeLapse += 100
							other.move(*other.movePerpendicular(doctor,-60))
						else:
							self.destruct()
			collisions = pygame.sprite.spritecollide(self, silence, False)
			for other in collisions:
				if other != self:
					if other in self.past:
						pass
					else:
						self.past.append(other)
						other.move(*other.moveRelative(doctor,-20))
						if randomizer > 9:
							print "STRIKE"
							everything.remove(other)
							silence.remove(other)
							everything2.remove(other)
						elif randomizer == 8:
							print "PROJECTION OF MAYHEM"
							#other.mayhem()
						elif randomizer < 3:
							print "ELECTRIC BACKFIRE"
							#other.shock()
						elif randomizer >= 5:
							print "FATIGUE"
							other.paralyzed = True
						else:
							print "BLINDNESS"
							other.blind = True
			collisions = pygame.sprite.spritecollide(self, reactors, False)
			for other in collisions:
				if other != self:
					reactors.remove(other)
					barriers.add(other)
			collisions = pygame.sprite.spritecollide(self, bombs, False)
			for other in collisions:
				if other != self:
					other.destruct()
			collisions = pygame.sprite.spritecollide(self, crates, False)
			for other in collisions:
				if other != self:
					other.destruct()
			collisions = pygame.sprite.spritecollide(self, ventGates, False)
			for other in collisions:
				if other != self:
					thing = other.rect.center
					everything.remove(other)
					everything2.remove(other)
					ventGates.remove(other)
					beamers.add(Beamer(thing,(random.choice(range(300)),random.choice(range(300)))))
			collisions = pygame.sprite.spritecollide(self, beamers, False)
			for other in collisions:
				if other != self:
					pass
			collisions = pygame.sprite.spritecollide(self, barriers, False)
			for other in collisions:
				if other != self and other.impermeable == False:
					everything.remove(other)
					barriers.remove(other)
			collisions = pygame.sprite.spritecollide(self, civilians, False)
			for other in collisions:
				if other != self:
					other.move(*other.moveRelative(doctor,60))
			return True
			self.past = self.past[-2:]
	def destruct(self):
		print "TIME RIFT"


class Doctor(Moveable):
	def __init__(self,pos):
		Moveable.__init__(self,pos,"doctor2.png")
		self.thingRight = False
		self.thingLeft = False
		self.thingDown = False
		self.thingUp = False
		self.sonicKey = False
		self.regenbolt = False
		self.d = "blegh!"
		self.sonicWave = None
		self.healing = False
		self.sprinting = False
		self.exploding = False
		self.counter = 0
		self.counter2 = 0
		self.energy = 300
		self.bolt = None
		self.rbolt = None
	def update(self):
		for item in pygame.event.get():
			if item.type == pygame.KEYDOWN and item.key == 275:
				self.thingRight = True
				self.d = (5,0)
			if item.type == pygame.KEYUP and item.key == 275:
				self.thingRight = False
			if item.type == pygame.KEYDOWN and item.key == 273:
				self.thingUp = True
				self.d = (0,-5)
			if item.type == pygame.KEYUP and item.key == 273:
				self.thingUp = False
			if item.type == pygame.KEYDOWN and item.key == 274:
				self.thingDown = True
				self.d = (0,5)
			if item.type == pygame.KEYUP and item.key == 274:
				self.thingDown = False
			if item.type == pygame.KEYDOWN and item.key == 276:
				self.thingLeft = True
				self.d = (-5,0)
			if item.type == pygame.KEYUP and item.key == 276: 
				self.thingLeft = False
			if item.type == pygame.KEYDOWN and item.key == 113:
				raise SystemExit
			if item.type == pygame.KEYDOWN and item.key == 115:
				self.sonicKey = True
			if item.type == pygame.KEYUP and item.key == 115:
				self.sonicKey = False
			if item.type == pygame.KEYDOWN and item.key == pygame.K_h:
				self.healing = True
			if item.type == pygame.KEYUP and item.key == pygame.K_h:
                                self.healing = False
			if item.type == pygame.KEYDOWN and item.key == pygame.K_f:
				if self.energy >= 200:
					self.sprinting = True
					self.counter2 = 40
			if item.type == pygame.KEYUP and item.key == pygame.K_f:
                                self.sprinting = False
			if item.type == pygame.KEYDOWN and item.key == pygame.K_r:
				self.regenbolt = True
			if item.type == pygame.KEYUP and item.key == pygame.K_r:
				self.regenbolt = False
		if self.thingRight == True:
			self.move(2,0)
		if self.thingLeft == True:
			self.move(-2,0)
		if self.thingUp == True:
			self.move(0,-2)
		if self.thingDown == True:
			self.move(0,2)
		if self.sprinting == True:
			self.counter2 -= 1
			if self.counter2 > 0:
				if self.thingRight == True:
					self.move(2,0)
				if self.thingLeft == True:
					self.move(-2,0)
				if self.thingUp == True:
					self.move(0,-2)
				if self.thingDown == True:
					self.move(0,2)
			else:
				self.energy -= 60
		if self.energy < 200:
			self.energy += 1
	def checkHealth(self,health,stamina,regen):
		if health < 0:
			if random.choice([1,2,3,4,5,6,7,8,9]) == 1:
				print "badly injured, get to the tardis"
                	if stamina < 0:
                        	print "Game Over--you died"
                       		raise SystemExit
                	regenorate =  pygame.sprite.spritecollide(self, tardises, False)
                        for other in regenorate:
                               	if other != self:
                                       	if regen > 70:
                                               	health = 15
						stamina = 350
						regen -= 100
					else:
						print "insufficient energy... Your pretty much screwed. These tricks can't always save you."
		collisionsA = pygame.sprite.spritecollide(self, deathbolts, False)
                for other in collisionsA:
	                if other != self:
                        	health = health -3
		collisionsC = pygame.sprite.spritecollide(self, speedbolts, False)
                for other in collisionsC:
	                if other != self:
                        	health = health -30
				print "ow"
		collisionsb = pygame.sprite.spritecollide(self, booms, False)
		for other in collisionsb:
			if other != self and other != self.bolt:
				health = health -4
		return health
	def heal(self, health, regen):
		rtn = [health,regen]
		if self.healing == True:
			if health < 15:
				if regen > 70:
					regen = regen - 75
					health = health + 1
					rtn = [health, regen]
					print "healing... health at ", health, " out of 15"
				else:
					print "cannot heal, insufficient regenorations"
			else:
				print "you are uninjured"
		return rtn
	def sonicDoor(self,regen):
		#print regen
		if self.sonicWave:
			if self.sonicWave.update() == False:
				sonics.remove(self.sonicWave)
				self.sonicWave = None
		elif self.sonicKey == True:
			direction = self.d
			self.sonicWave = sonicWave(self.rect.center,direction)
			sonics.add(self.sonicWave)
		if self.rbolt:
			if self.rbolt.update() == False:
				sonics.remove(self.rbolt)
				self.rbolt = None
		elif self.regenbolt == True and regen > 600:
			direction = self.d
			self.rbolt = regenbolt(self.rect.center,direction)
			sonics.add(self.rbolt)
			regen -= 600
		return regen
pygame.init()
screen = pygame.display.set_mode((800,800))
screen.fill((150,150,200))
pygame.display.update()
daleks = pygame.sprite.RenderUpdates()
speedydaleks = pygame.sprite.RenderUpdates()
weapondaleks = pygame.sprite.RenderUpdates()
doctors = pygame.sprite.RenderUpdates()
barriers = pygame.sprite.RenderUpdates()
ventGates = pygame.sprite.RenderUpdates()
reactors = pygame.sprite.RenderUpdates()
bombs = pygame.sprite.RenderUpdates()
crates = pygame.sprite.RenderUpdates()
tardises = pygame.sprite.RenderUpdates()
civilians = pygame.sprite.RenderUpdates()
ponds = pygame.sprite.RenderUpdates()
angels = pygame.sprite.RenderUpdates()
rorys = pygame.sprite.RenderUpdates()
cybers = pygame.sprite.RenderUpdates()
silence = pygame.sprite.RenderUpdates()
beamers = pygame.sprite.RenderUpdates()

#IMPORTANT
#READ ME
#Make a 'team' class. Each team will have a def for how it deals with each other team. Each team will also be in a renderupdates group, as members of a team will observe other team groups. Team defs will allow, say, a silence, and a silence order member, to use the same def, as the def will basically say, "if you have this info", or perhaps, "if your a silence". Basically, a team represents the main AI of a group. Some very individual exceptions will be present, so that a specific team member type could treat another team type radically differently from the others, or even be a rogue fighter on the team.
#READ THE ABOVE
#IMPORTANT

if level == '':
	level = 'setup1'

if level == "standard":
	#intro
	print "Be ready to deal with a large squad of daleks and a rogue weeping angel... And, of coarse, to protect civilians, amy, and rory."
	#dalek placement
	speedydaleks.add(SpeedyDalek((150,300)),SpeedyDalek((150,600)))
	daleks.add(Dalek((100,200)),Dalek((300,500)),Dalek((300,700)),Dalek((500,100)),Dalek((300,100)),silenceorder((200,50)),silenceorder((250,100)),silenceorder((300,150)))
	weapondaleks.add(SpecialWeaponsDalek((200,300)))
	#cyber placement
	cybers.add(cyberman((50,50)),cyberman((350,470)))
	#silence placement
	silence.add(Silence((100,700)))
	#civilian placement
	civilians.add(Civilian((200,500)),Civilian((625,600)),Civilian((400,400)),Civilian((700,100)),Civilian((700,500)),Civilian((400,500)))
	#environment placement
	crates.add(Crate((100,300)),Crate((500,650)))
	reactors.add(Reactor((700,600)),Reactor((100,400)),Reactor((600,100)))
	bombs.add(Bomb((100,500)),Bomb((500,500)),Bomb((100,500)))
	ventGates.add(VentGate((600,600)),VentGate((100,150)),VentGate((100,600)),VentGate((667,360)))
	beamers.add(Beamer((420,420),(0,-100)))
	#angel placement
	angels.add(WeepingAngel((550,550)))
	#specific level
	barriers.add(Wall((600,225)),Wall((625,532)),Wall((300,548)),Wall((197,263)),Wall((150,150)))
	barriers.add(Wall((725,250)),Wall((430,709)),Wall((409,612)),Wall((400,45)),Wall((400,90)),Wall((400,135)),Wall	((400,180)),Wall((400,225)),Wall((400,270)),Wall((400,315)),Wall((400,360)))
	barriers.add(Wall((445,360)),Wall((490,360)),Wall((535,360)),Wall((570,360)),Wall((615,360)),Wall((715,360)),Wall((750,360)),Wall((795,360)))
	#doctor, pond, rory, and tardis placement
	doctor = Doctor((500,600))
	doctors.add(doctor)
	pond = Pond((150,400))
	ponds.add(pond)
	#rory = Rory((200,400))
	#rorys.add(rory)
	tardis = Tardis((700,700))
	tardises.add(tardis)
	levelmsg = "Well done. Soon, there will be more maps. When they do come, you can find new maps along several paths. You could use names as map seed numbers to get random maps, you can say rand1, rand2, and so on to get carefull blends of random and scripted positions for a fun game, you could use setup1, the one you probably played first, to experience a chain of scripted maps that may be interesting. There may yet be bonus content."
elif level == "insane191030243":
	pass
elif level == "rand1":
	pass
elif level == "setup1":
	#NEW SETUP ------------------------------------- NEW SETUP ---------------------------------------- NEW SETUP
	#time rifts: note: to units, rifts will suck them in and kill them, even angels. angels can also be killed by two simultaneous explosions. to other things, like sonics, death rays, and heal rays, it will transport them a certain amount into the future, by a number seen on the rift. This gives a mirror and delay. And, ofcoarse, a rift could possibly have certain times it is present or not, and a unit will keep it to occupied to suck in other units for a few seconds. There is such a thing as a rift explosion, which is a larger, short lived time rift. Regenoration blasts will heal allies, push all enemies, have roughly a fifty percent chance of destroying a wall it passes through, and could possibly explode which would kill enemies, could possibly cause a small rift explosion, or could possibly kill an enemy. It will also, of coarse, have a chance of just pushing them. This depends partly upon the enemy, partly upon randomness, and partly upon later progression. They can also supressively implode volatile map components.
	#intro
	print "This setup includes a dalek outpost with captive civilians, an attacking force of silence, a lone cyberman pursuer, and a large amount of weeping angels in an abandoned mine. Good luck..."
	#NOTE: ALL THAT REMAINS TO BE PLACED IS DALEK AND ENVIRONMENT PLACEMENT
	#dalek placement
	speedydaleks.add(SpeedyDalek((320,150)),SpeedyDalek((370,150)))
	daleks.add(Dalek((55,150)),Dalek((105,150)),Dalek((155,150)),Dalek((128,200)),Dalek((340,375)),silenceorder((700,100)),silenceorder((750,150)),silenceorder((700,100)))
	weapondaleks.add(SpecialWeaponsDalek((78,200)),SpecialWeaponsDalek((290,325)))
	#silence placement
	silence.add(Silence((750,50)),Silence((750,100)),Silence((700,50)))
	#cyber placement
	cybers.add(cyberman((375,600)),cyberman((300,600)))
	#civilian placement
	civilians.add(Civilian((540,40)),Civilian((540,90)),Civilian((650,50)),Civilian((750,200)),Civilian((100,600)),Civilian((50,600)))
	#environment placement
	crates.add(Crate((320,100)),Crate((370,100)))
	reactors.add(Reactor((125,385)),Reactor((370,340)),Reactor((370,390)))
	bombs.add(Bomb((55,100)),Bomb((105,100)),Bomb((155,100)))
	bombs.add(Bomb((475,240)),Bomb((525,240)))
	ventGates.add(VentGate((210,190)))
	beamers.add(Beamer((160,325),(100,0)))
	#angel placement
	angels.add(WeepingAngel((610,610)),WeepingAngel((580,580)),WeepingAngel((610,640)),WeepingAngel((580,640)),WeepingAngel((640,580)))
	#outpost outer wall
	barriers.add(Wall((420,40)),Wall((420,90)),Wall((420,140)),Wall((420,190)),Wall((420,240)))
	barriers.add(Wall((420,290)),Wall((420,340)),Wall((420,390)),Wall((420,440)),Wall((370,440)),Wall((320,440)),Wall((270,440)),Wall((220,440)),Wall((170,440)),Wall((120,440)),Wall((70,440)),Wall((20,440)))
	#outpost interior rooms
	barriers.add(Wall((210,40)),Wall((210,90)),Wall((210,140)),Wall((210,240)),Wall((210,290)),Wall((210,340)),Wall((210,390)),Wall((210,440)))
	barriers.add(Wall((260,240)),Wall((310,240)),Wall((360,240)),Wall((410,240)),Wall((420,240)))
	#outpost prison
	barriers.add(Wall((490,40)),Wall((490,90)),Wall((490,140)),Wall((490,190)),Wall((540,190)),Wall((590,190)),Wall((590,140)),Wall((590,90)),Wall((590,40)))
	#stone mine
	barriers.add(StoneWall((700,700)),StoneWall((640,700)),StoneWall((580,700)),StoneWall((520,700)),StoneWall((520,640)),StoneWall((520,580)),StoneWall((520,520)),StoneWall((580,520)),StoneWall((640,520)),StoneWall((700,520)),StoneWall((700,580)),StoneWall((700,640)))
	#doctor, pond, rory, and tardis placement
	doctor = Doctor((100,700))
	doctors.add(doctor)
	pond = Pond((50,750))
	ponds.add(pond)
	rory = Rory((50,700))
	rorys.add(rory)
	tardis = Tardis((100,750))
	tardises.add(tardis)
	levelmsg = "Well done. You just completed the coordinates setup1, the standard layout. The next sequential setup will be setup2_989. This is likely to be available in the next update. Type arena for the only other completed setup. Though I doubt you will invest this much time in this thing, I may later encorporate some greater form of progression that will grant you a few choices in the doctor's controls and stuff."
elif level == "plot1":
	pass
else:
	print "error: Specify proper coordinates. Standard is a good keyphrase to begin with."
	raise RuntimeError

#wall borders
barriers.add(Wall((0,0),True),Wall((0,45),True),Wall((0,90),True),Wall((0,135),True),Wall((0,180),True),Wall((0,225),True),Wall((0,270),True),Wall((0,315),True),Wall((0,360),True))
barriers.add(Wall((0,495),True),Wall((0,540),True),Wall((0,585),True))
barriers.add(Wall((0,405),True),Wall((0,450),True),Wall((0,595),True),Wall((0,640),True),Wall((0,685),True),Wall((0,730),True),Wall((0,775),True),Wall((0,800),True))
barriers.add(Wall((45,0),True),Wall((90,0),True),Wall((135,0),True),Wall((180,0),True),Wall((225,0),True),Wall((270,0),True),Wall((315,0),True),Wall((360,0),True))
barriers.add(Wall((495,0),True),Wall((540,0),True),Wall((585,0),True))
barriers.add(Wall((405,0),True),Wall((450,0),True),Wall((595,0),True),Wall((640,0),True),Wall((685,0),True),Wall((730,0),True),Wall((775,0),True),Wall((800,0),True))
barriers.add(Wall((800,45),True),Wall((800,90),True),Wall((800,135),True),Wall((800,180),True),Wall((800,225),True),Wall((800,270),True),Wall((800,315),True),Wall((800,360),True))
barriers.add(Wall((800,495)),Wall((800,540)),Wall((800,585)))
barriers.add(Wall((800,405)),Wall((800,450)),Wall((800,595)),Wall((800,640)),Wall((800,685)),Wall((800,730)),Wall((800,775)),Wall((800,800)))
barriers.add(Wall((45,800)),Wall((90,800)),Wall((135,800)),Wall((180,800)),Wall((225,800)),Wall((270,800)),Wall((315,800)),Wall((360,800)))
barriers.add(Wall((495,800)),Wall((540,800)),Wall((585,800)))
barriers.add(Wall((405,800)),Wall((450,800)),Wall((595,800)),Wall((640,800)),Wall((685,800)),Wall((730,800)),Wall((775,800)),Wall((800,800)))

def PossibleReconsrtruct():
	variable = random.randint(1,700)
	if variable == 9:
		pygame.display.update(barriers.draw(screen))

everything.add(daleks,doctors,barriers,reactors,bombs,weapondaleks,ponds,civilians,speedydaleks,angels,rorys,cybers,silence)
everything2.add(daleks,doctors,barriers,reactors,bombs,ponds,civilians,speedydaleks,angels,rorys,silence)
#This group represents things angels will pay attetion to. The order represents their priority. Angels will not attack eachother, however. They just pay attention to eachother's observation.
everything7.add(daleks,weapondaleks,doctors,ponds,civilians,speedydaleks,angels,rorys,cybers)
foes.add(daleks,weapondaleks,speedydaleks,cybers,silence)
pygame.display.update(daleks.draw(screen))
pygame.display.update(doctors.draw(screen))
pygame.display.update(barriers.draw(screen))
pygame.display.update(reactors.draw(screen))
pygame.display.update(bombs.draw(screen))
pygame.display.update(crates.draw(screen))
pygame.display.update(tardises.draw(screen))
pygame.display.update(weapondaleks.draw(screen))
pygame.display.update(civilians.draw((screen)))
pygame.display.update(ponds.draw((screen)))
pygame.display.update(speedydaleks.draw((screen)))
pygame.display.update(angels.draw((screen)))
pygame.display.update(rorys.draw((screen)))
pygame.display.update(cybers.draw((screen)))
pygame.display.update(silence.draw((screen)))
pygame.display.update(beamers.draw((screen)))
echoHealth = False

print regen

while True:
	daleks.update()
	weapondaleks.update()
	speedydaleks.update()
	pond.update()
	try:
		rory.update()
	except NameError, e:
		pass
	for civilian in civilians:
		rtn2 = civilian.update(saved, dead)
		if rtn2 != None:
			saved = rtn2[0]
			dead = rtn2[1]
		else:
			pass
	doctor.update()
	regen = doctor.sonicDoor(regen)
	angels.update(everything7)
	cybers.update(everything7)
	silence.update(everything7)
	beamers.update()
	health = doctor.checkHealth(health,stamina,regen)
	rtn = doctor.heal(health,regen)
	health = rtn[0]
	regen = rtn[1]
	if health < 0:
		stamina = stamina - 1
	time.sleep(0.04)
	if regen < 900:
		#regen = regen + 10
		regen = regen + .4
	pygame.display.update(daleks.draw(screen))
	pygame.display.update(doctors.draw(screen))
	pygame.display.update(deathbolts.draw(screen))
	pygame.display.update(boombolts.draw(screen))
	pygame.display.update(speedbolts.draw((screen)))
	pygame.display.update(sonics.draw(screen))
	pygame.display.update(ventGates.draw(screen))
	pygame.display.update(crates.draw(screen))
	pygame.display.update(tardises.draw(screen))
	pygame.display.update(weapondaleks.draw(screen))
	pygame.display.update(civilians.draw(screen))
	pygame.display.update(ponds.draw((screen)))
	pygame.display.update(speedydaleks.draw((screen)))
	pygame.display.update(angels.draw((screen)))
	pygame.display.update(rorys.draw((screen)))
	pygame.display.update(cybers.draw((screen)))
	pygame.display.update(silence.draw((screen)))
	pygame.display.update(beamers.draw((screen)))
	PossibleReconsrtruct()
	for boom in booms:
		collisionsA = pygame.sprite.spritecollide(boom, barriers, False)
                for other in collisionsA:
	                if other != boom and other.impermeable == False:
				everything.remove(other)
				barriers.remove(other)
	for VentGate in ventGates:
		VentGate.openedClosed()
	for reactor in reactors:
		detonation = reactor.PossibleExplode()
		if detonation == True:
			pygame.display.update(reactors.draw(screen))
	for bomb in bombs:
       	        detonation = bomb.PossibleExplode()
                if detonation == True:
                        pygame.display.update(bombs.draw(screen))
	for crate in crates:
		detonation = crate.PossibleExplode()
		if detonation == True:
			pygame.display.update(crates.draw(screen))
	for boombolt in boombolts:
		detonation = boombolt.PossibleExplode()
		if detonation == True:
			pygame.display.update(boombolts.draw(screen))
	if random.choice(range(200)) == 7:
		print 'saved', saved, 'dead', dead, 'health', health, 'regenoration energy', regen
	if dead == 12:
		print "Game Over, excessive deaths of civilians. You shouldn't let twelve civilians get slaughtered like that. You must be almost trying to kill them. Seriously..."
		raise SystemExit
	if saved >= 4 or dead < 8:
		if len(daleks) == 0 and len(weapondaleks) == 0 and len(speedydaleks) == 0 and len(silence) == 0:
			endcollisions = pygame.sprite.spritecollide(doctor, tardises, False)
			for other in endcollisions:
				if other != doctor:
					print "YOU WIN!!!"
					print levelmsg
					raise SystemExit
	#tesselector, terminals for map control, ptyradactal pests, demons run, wide gates, vasta nerada, adipose, torchwood, prisoner 0, river song, k9, subteranean reptile whatevertheyrecalled, headless monks, face of boe, captian jack, gas maskers, red waterfall bots, ood, dalek prison, dalek asylum nanofeild, tooth and claw, expanded silence, whispermen, past companions, tardis interior, mines, objects through time rifts, emps, turrets
